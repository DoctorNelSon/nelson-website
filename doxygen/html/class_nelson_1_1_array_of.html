<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Nelson: Nelson::ArrayOf Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="banner_nelson_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nelson
   &#160;<span id="projectnumber">0.1.12</span>
   </div>
   <div id="projectbrief">Nelson numerical interpreter</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_nelson_1_1_array_of.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_nelson_1_1_array_of-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Nelson::ArrayOf Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_array_of_8hpp_source.html">ArrayOf.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af59ca1b6b8b82ec41fbffa1d56dec4cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#af59ca1b6b8b82ec41fbffa1d56dec4cc">toOrdinalType</a> ()</td></tr>
<tr class="separator:af59ca1b6b8b82ec41fbffa1d56dec4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829e7c989b5a76a48e35a52b02265203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a829e7c989b5a76a48e35a52b02265203">ensureSingleOwner</a> ()</td></tr>
<tr class="separator:a829e7c989b5a76a48e35a52b02265203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a72e0db830056c46ef8ea9dab24e4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ac7a72e0db830056c46ef8ea9dab24e4e">ArrayOf</a> ()</td></tr>
<tr class="separator:ac7a72e0db830056c46ef8ea9dab24e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78abac9c4b66126f5010deea512a7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a1d78abac9c4b66126f5010deea512a7e">ArrayOf</a> (const <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;copy)</td></tr>
<tr class="separator:a1d78abac9c4b66126f5010deea512a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7cbe5880d62fbb33696602150a80c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aee7cbe5880d62fbb33696602150a80c2">ArrayOf</a> (Class type)</td></tr>
<tr class="separator:aee7cbe5880d62fbb33696602150a80c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe51353747bb5c554dcebd4f8e94ecb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#abe51353747bb5c554dcebd4f8e94ecb5">ArrayOf</a> (Class, const <a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;, void *, bool sparse=false, const stringVector &amp;=stringVector())</td></tr>
<tr class="separator:abe51353747bb5c554dcebd4f8e94ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dace5f733c845dcedb3db33918a6e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a33dace5f733c845dcedb3db33918a6e3">~ArrayOf</a> ()</td></tr>
<tr class="separator:a33dace5f733c845dcedb3db33918a6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3671a3c4dd0b295c4746f4fc50bbfbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ad3671a3c4dd0b295c4746f4fc50bbfbd">operator=</a> (const <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;copy)</td></tr>
<tr class="separator:ad3671a3c4dd0b295c4746f4fc50bbfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcbd81425f3f709a9f8b2ec05247d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#afbcbd81425f3f709a9f8b2ec05247d55">getReferenceCount</a> () const </td></tr>
<tr class="separator:afbcbd81425f3f709a9f8b2ec05247d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d29b68719440347d24eaad1bb772789"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a0d29b68719440347d24eaad1bb772789">getLength</a> () const </td></tr>
<tr class="separator:a0d29b68719440347d24eaad1bb772789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10e3aa095b78fdb602e453ed1f4d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aef10e3aa095b78fdb602e453ed1f4d25">getDimensions</a> () const </td></tr>
<tr class="separator:aef10e3aa095b78fdb602e453ed1f4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373e06286130d08962da5cb197519b60"><td class="memItemLeft" align="right" valign="top">stringVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a373e06286130d08962da5cb197519b60">getFieldNames</a> () const </td></tr>
<tr class="separator:a373e06286130d08962da5cb197519b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ca93ea1ba2691872bdfb55eebfa49"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aae5ca93ea1ba2691872bdfb55eebfa49">getDimensionLength</a> (int) const </td></tr>
<tr class="separator:aae5ca93ea1ba2691872bdfb55eebfa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c7816ab1b0d6aa266f9dadeb2530b4"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ad2c7816ab1b0d6aa266f9dadeb2530b4">getDataPointer</a> () const </td></tr>
<tr class="separator:ad2c7816ab1b0d6aa266f9dadeb2530b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac77ce6941e323a3cb1da3f42e8d2a62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac77ce6941e323a3cb1da3f42e8d2a62"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getSparseDataPointer</b> () const </td></tr>
<tr class="separator:aac77ce6941e323a3cb1da3f42e8d2a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad4fb5d10fbabf71395778e1d72345"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a59ad4fb5d10fbabf71395778e1d72345">getReadWriteDataPointer</a> ()</td></tr>
<tr class="separator:a59ad4fb5d10fbabf71395778e1d72345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a92a544609db3d31b8c430ac0f02ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ab2a92a544609db3d31b8c430ac0f02ce">setDataPointer</a> (void *)</td></tr>
<tr class="separator:ab2a92a544609db3d31b8c430ac0f02ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30ded9f2beed8913848aaf1882ebb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aa30ded9f2beed8913848aaf1882ebb65">resize</a> (<a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;a)</td></tr>
<tr class="separator:aa30ded9f2beed8913848aaf1882ebb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2ebcbb1b410e25d9b247112696945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a54f2ebcbb1b410e25d9b247112696945">vectorResize</a> (indexType)</td></tr>
<tr class="separator:a54f2ebcbb1b410e25d9b247112696945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214c5e1c4f0ba588150aaaf3844f6db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a3214c5e1c4f0ba588150aaaf3844f6db">reshape</a> (<a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;a)</td></tr>
<tr class="separator:a3214c5e1c4f0ba588150aaaf3844f6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeded4de7723da708811252fbbf473406"><td class="memItemLeft" align="right" valign="top">Class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aeded4de7723da708811252fbbf473406">getDataClass</a> () const </td></tr>
<tr class="separator:aeded4de7723da708811252fbbf473406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6417d5a73a619e7b715d72e80227f260"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a6417d5a73a619e7b715d72e80227f260">getElementSize</a> () const </td></tr>
<tr class="separator:a6417d5a73a619e7b715d72e80227f260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702d62df7e115010bcb463aed16c9d84"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a702d62df7e115010bcb463aed16c9d84">getByteSize</a> () const </td></tr>
<tr class="separator:a702d62df7e115010bcb463aed16c9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1982cea81188dbeb7eeb9516e633f5df"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a1982cea81188dbeb7eeb9516e633f5df">isPositive</a> () const </td></tr>
<tr class="separator:a1982cea81188dbeb7eeb9516e633f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3edf314c6de3d9a3d196b511f1b22a4"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#af3edf314c6de3d9a3d196b511f1b22a4">isRealAllZeros</a> () const </td></tr>
<tr class="separator:af3edf314c6de3d9a3d196b511f1b22a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf5a280b18d664b5e6d36bf0ffc167d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bf5a280b18d664b5e6d36bf0ffc167d"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSparse</b> () const </td></tr>
<tr class="separator:a6bf5a280b18d664b5e6d36bf0ffc167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e3957dc57a61b8a879966fb9f116a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953e3957dc57a61b8a879966fb9f116a"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSparseDouble</b> () const </td></tr>
<tr class="separator:a953e3957dc57a61b8a879966fb9f116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcede4c4af711d2bdd31f5bac5edb3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bcede4c4af711d2bdd31f5bac5edb3c"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSparseLogical</b> () const </td></tr>
<tr class="separator:a7bcede4c4af711d2bdd31f5bac5edb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb660269d2f07a07f920233f9623e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89eb660269d2f07a07f920233f9623e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeSparse</b> ()</td></tr>
<tr class="separator:a89eb660269d2f07a07f920233f9623e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b34a1ed8f7eabd3c0f4ab50021dcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada4b34a1ed8f7eabd3c0f4ab50021dcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeDense</b> ()</td></tr>
<tr class="separator:ada4b34a1ed8f7eabd3c0f4ab50021dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5670e0444d66770136f0bff96015134b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5670e0444d66770136f0bff96015134b"></a>
indexType&#160;</td><td class="memItemRight" valign="bottom"><b>getNonzeros</b> () const </td></tr>
<tr class="separator:a5670e0444d66770136f0bff96015134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b86d2bea7ce4103dcbd5cd643e5b1bb"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a7b86d2bea7ce4103dcbd5cd643e5b1bb">testCaseMatchScalar</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> x) const </td></tr>
<tr class="separator:a7b86d2bea7ce4103dcbd5cd643e5b1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43a994aa8b41aad19d0b48b70020a4"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a4f43a994aa8b41aad19d0b48b70020a4">testForCaseMatch</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> x) const </td></tr>
<tr class="separator:a4f43a994aa8b41aad19d0b48b70020a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71313e6b6ae0374803228677cd86a9b1"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a71313e6b6ae0374803228677cd86a9b1">isEmpty</a> (bool allDimensionsIsZero=false) const </td></tr>
<tr class="separator:a71313e6b6ae0374803228677cd86a9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f2a55d70eb97387c8d7101aaf83dc"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a618f2a55d70eb97387c8d7101aaf83dc">isScalar</a> () const </td></tr>
<tr class="separator:a618f2a55d70eb97387c8d7101aaf83dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a013e67d796f159d5ef9a9de68dfc9"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a51a013e67d796f159d5ef9a9de68dfc9">is2D</a> () const </td></tr>
<tr class="separator:a51a013e67d796f159d5ef9a9de68dfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022cd4577944fb1a3d61f2ce454723aa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a022cd4577944fb1a3d61f2ce454723aa">isSquare</a> () const </td></tr>
<tr class="separator:a022cd4577944fb1a3d61f2ce454723aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60614f939042f9214550864d9c70199a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a60614f939042f9214550864d9c70199a">isVector</a> () const </td></tr>
<tr class="separator:a60614f939042f9214550864d9c70199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685e40a51e62e984092bf868f327ae1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a685e40a51e62e984092bf868f327ae1b"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isRowVector</b> () const </td></tr>
<tr class="separator:a685e40a51e62e984092bf868f327ae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133ab3809337728de11d64c9eaa25f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af133ab3809337728de11d64c9eaa25f5"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isColumnVector</b> () const </td></tr>
<tr class="separator:af133ab3809337728de11d64c9eaa25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929aba4235e243bee8985990d8e8614c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a929aba4235e243bee8985990d8e8614c">isReferenceType</a> () const </td></tr>
<tr class="separator:a929aba4235e243bee8985990d8e8614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221309ca0f64bd2177769b1e7ab68915"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a221309ca0f64bd2177769b1e7ab68915">isComplex</a> () const </td></tr>
<tr class="separator:a221309ca0f64bd2177769b1e7ab68915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f8cd00ed880539770408d0b6450762"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#af3f8cd00ed880539770408d0b6450762">isReal</a> () const </td></tr>
<tr class="separator:af3f8cd00ed880539770408d0b6450762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07efba2fd634afec74e730db0f73e60"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ab07efba2fd634afec74e730db0f73e60">allReal</a> () const </td></tr>
<tr class="separator:ab07efba2fd634afec74e730db0f73e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c734ea55e9ac3d5ef17bb195ae450c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ae8c734ea55e9ac3d5ef17bb195ae450c">isDoubleSparseType</a> () const </td></tr>
<tr class="separator:ae8c734ea55e9ac3d5ef17bb195ae450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e9072159be4b86ed517f6906e9c67"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a031e9072159be4b86ed517f6906e9c67">isNdArrayDoubleType</a> () const </td></tr>
<tr class="separator:a031e9072159be4b86ed517f6906e9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bad2aace887b8e8586400f3b5d2cb64"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a3bad2aace887b8e8586400f3b5d2cb64">isDoubleType</a> () const </td></tr>
<tr class="separator:a3bad2aace887b8e8586400f3b5d2cb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2f1f165d537bf09faffeeedf548a5"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a0ce2f1f165d537bf09faffeeedf548a5">isSingleType</a> () const </td></tr>
<tr class="separator:a0ce2f1f165d537bf09faffeeedf548a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4ca799bce96f352134aea30623f48"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#adff4ca799bce96f352134aea30623f48">isNdArraySingleType</a> () const </td></tr>
<tr class="separator:adff4ca799bce96f352134aea30623f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827f47d84a1bbb1c65f9c74bd0fcdbf4"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a827f47d84a1bbb1c65f9c74bd0fcdbf4">isString</a> () const </td></tr>
<tr class="separator:a827f47d84a1bbb1c65f9c74bd0fcdbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec435bf25e08824251a38df1f4c3ddee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec435bf25e08824251a38df1f4c3ddee"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSingleString</b> () const </td></tr>
<tr class="separator:aec435bf25e08824251a38df1f4c3ddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfee32f4d907c172eea5cad0953a27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cbfee32f4d907c172eea5cad0953a27"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNdArrayStringType</b> () const </td></tr>
<tr class="separator:a5cbfee32f4d907c172eea5cad0953a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e067e13e98f7a6af9530fb63a681d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91e067e13e98f7a6af9530fb63a681d4"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isIntegerType</b> () const </td></tr>
<tr class="separator:a91e067e13e98f7a6af9530fb63a681d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfea058a5b53db457879a79271d9261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dfea058a5b53db457879a79271d9261"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNdArrayIntegerType</b> () const </td></tr>
<tr class="separator:a0dfea058a5b53db457879a79271d9261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfab244ba48990a447b1ae10fe61ff24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#adfab244ba48990a447b1ae10fe61ff24">copyElements</a> (indexType srcIndex, void *dstPtr, indexType dstIndex, indexType count)</td></tr>
<tr class="separator:adfab244ba48990a447b1ae10fe61ff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303cf47a5ceeea987b2fe35359a90add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a303cf47a5ceeea987b2fe35359a90add">promoteType</a> (Class new_type, stringVector fieldNames)</td></tr>
<tr class="separator:a303cf47a5ceeea987b2fe35359a90add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d6932c50267e037e996791fc952441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a53d6932c50267e037e996791fc952441">promoteType</a> (Class new_type)</td></tr>
<tr class="separator:a53d6932c50267e037e996791fc952441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e48b1a0fbbfad999d9748e85a914c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a18e48b1a0fbbfad999d9748e85a914c4">getValueAtIndex</a> (uint64 index)</td></tr>
<tr class="separator:a18e48b1a0fbbfad999d9748e85a914c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5706665727676d93fecdd91289812630"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5706665727676d93fecdd91289812630"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setValueAtIndex</b> (uint64 index, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> scalarValue)</td></tr>
<tr class="separator:a5706665727676d93fecdd91289812630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884c77dbdff80afc89c2f6742bcc5162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a884c77dbdff80afc89c2f6742bcc5162">getVectorSubset</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index)</td></tr>
<tr class="separator:a884c77dbdff80afc89c2f6742bcc5162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd61022a590f59e438c9f4a68da4da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aefd61022a590f59e438c9f4a68da4da4">getNDimSubset</a> (ArrayOfVector &amp;index)</td></tr>
<tr class="separator:aefd61022a590f59e438c9f4a68da4da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c691f165c485b98797efe087ab2d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ac9c691f165c485b98797efe087ab2d67">getVectorContents</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index)</td></tr>
<tr class="separator:ac9c691f165c485b98797efe087ab2d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40da3e09837c3479e3cd5cd32979aab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a40da3e09837c3479e3cd5cd32979aab9">getNDimContents</a> (ArrayOfVector &amp;index)</td></tr>
<tr class="separator:a40da3e09837c3479e3cd5cd32979aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5401338db1279ea48504f3fb75544c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#afa5401338db1279ea48504f3fb75544c">getField</a> (std::string fieldName)</td></tr>
<tr class="separator:afa5401338db1279ea48504f3fb75544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ce3b60e66c2872361d28f1c82bdc11"><td class="memItemLeft" align="right" valign="top">ArrayOfVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aa3ce3b60e66c2872361d28f1c82bdc11">getFieldAsList</a> (std::string fieldName)</td></tr>
<tr class="separator:aa3ce3b60e66c2872361d28f1c82bdc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba1f8d0c89eb7f6c1a730067689be1"><td class="memItemLeft" align="right" valign="top">ArrayOfVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a96ba1f8d0c89eb7f6c1a730067689be1">getVectorContentsAsList</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index)</td></tr>
<tr class="separator:a96ba1f8d0c89eb7f6c1a730067689be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851a8bd83c9f69960af6a0747d27e86"><td class="memItemLeft" align="right" valign="top">ArrayOfVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a6851a8bd83c9f69960af6a0747d27e86">getNDimContentsAsList</a> (ArrayOfVector &amp;index)</td></tr>
<tr class="separator:a6851a8bd83c9f69960af6a0747d27e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641603bbbf6d76aa4f8cb686c89dc48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a641603bbbf6d76aa4f8cb686c89dc48d">setVectorSubset</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;data)</td></tr>
<tr class="separator:a641603bbbf6d76aa4f8cb686c89dc48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b558b3f69a9dcd28bb6647be4739d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a5b558b3f69a9dcd28bb6647be4739d05">setNDimSubset</a> (ArrayOfVector &amp;index, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;data)</td></tr>
<tr class="separator:a5b558b3f69a9dcd28bb6647be4739d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df999bbda12f33f387e1f77631b868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ab7df999bbda12f33f387e1f77631b868">setVectorContents</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;data)</td></tr>
<tr class="separator:ab7df999bbda12f33f387e1f77631b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff74b220bbbe86695c5c99f06079097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a3ff74b220bbbe86695c5c99f06079097">setNDimContents</a> (ArrayOfVector &amp;index, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;data)</td></tr>
<tr class="separator:a3ff74b220bbbe86695c5c99f06079097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f28a5d06a9b510d5680a8f0d25c723b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a5f28a5d06a9b510d5680a8f0d25c723b">setField</a> (std::string fieldName, <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;data)</td></tr>
<tr class="separator:a5f28a5d06a9b510d5680a8f0d25c723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e47a8aa3fb77b04da776eae43c9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a7a2e47a8aa3fb77b04da776eae43c9e8">setVectorContentsAsList</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;index, ArrayOfVector &amp;data)</td></tr>
<tr class="separator:a7a2e47a8aa3fb77b04da776eae43c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a6c83bf9b0be24a9c14f51cc66bf51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ab5a6c83bf9b0be24a9c14f51cc66bf51">setNDimContentsAsList</a> (ArrayOfVector &amp;index, ArrayOfVector &amp;data)</td></tr>
<tr class="separator:ab5a6c83bf9b0be24a9c14f51cc66bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5596079303590cef42455dd339fdda39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a5596079303590cef42455dd339fdda39">setFieldAsList</a> (std::string fieldName, ArrayOfVector &amp;data)</td></tr>
<tr class="separator:a5596079303590cef42455dd339fdda39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8a5194e72bc298d250c808b5979dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a7d8a5194e72bc298d250c808b5979dde">deleteVectorSubset</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;ndx)</td></tr>
<tr class="separator:a7d8a5194e72bc298d250c808b5979dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26b16a2e6646d2c7c5420b53309901b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ab26b16a2e6646d2c7c5420b53309901b">deleteNDimSubset</a> (ArrayOfVector &amp;args)</td></tr>
<tr class="separator:ab26b16a2e6646d2c7c5420b53309901b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67247643b1bf80862e55dfc7f5ac4b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a67247643b1bf80862e55dfc7f5ac4b63">summarizeCellEntry</a> () const </td></tr>
<tr class="separator:a67247643b1bf80862e55dfc7f5ac4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad176a38b9c52c54788e86797860df757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ad176a38b9c52c54788e86797860df757">printMe</a> (int printLimit, sizeType termWidth=80) const </td></tr>
<tr class="separator:ad176a38b9c52c54788e86797860df757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5319308233d81b5ea169b4380b8b734"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ae5319308233d81b5ea169b4380b8b734">getContentAsCString</a> (void) const </td></tr>
<tr class="separator:ae5319308233d81b5ea169b4380b8b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2b3f698b01295e68f76e26c6fd464b"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#acb2b3f698b01295e68f76e26c6fd464b">getContentAsWideString</a> () const </td></tr>
<tr class="separator:acb2b3f698b01295e68f76e26c6fd464b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951356ab980faed328404a1c0e545620"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951356ab980faed328404a1c0e545620"></a>
std::wstring&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsArrayOfCharacters</b> () const </td></tr>
<tr class="separator:a951356ab980faed328404a1c0e545620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadbec4dd6b43bc0e788d4ec4472d00f"><td class="memItemLeft" align="right" valign="top">wstringVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#acadbec4dd6b43bc0e788d4ec4472d00f">getContentAsWideStringVector</a> (bool bCheckVector=true) const </td></tr>
<tr class="separator:acadbec4dd6b43bc0e788d4ec4472d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcb0bb65fcc86bb93d1ab40b9cb40b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fcb0bb65fcc86bb93d1ab40b9cb40b6"></a>
stringVector&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsCStringVector</b> (bool bCheckVector=true) const </td></tr>
<tr class="separator:a4fcb0bb65fcc86bb93d1ab40b9cb40b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f020fe30149a63634055a49b793dd"><td class="memItemLeft" align="right" valign="top">wstringVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9f2f020fe30149a63634055a49b793dd">getContentAsWideStringRowVector</a> (void) const </td></tr>
<tr class="separator:a9f2f020fe30149a63634055a49b793dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4d403403021fc2c4020a6bae15c176"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4d403403021fc2c4020a6bae15c176"></a>
stringVector&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsCStringRowVector</b> (void) const </td></tr>
<tr class="separator:aec4d403403021fc2c4020a6bae15c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875b8f92049fa13075586a29df40d7e5"><td class="memItemLeft" align="right" valign="top">wstringVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a875b8f92049fa13075586a29df40d7e5">getContentAsWideStringColumnVector</a> (void) const </td></tr>
<tr class="separator:a875b8f92049fa13075586a29df40d7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cc4e7a4d441fb9f06dcb1374b278c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4cc4e7a4d441fb9f06dcb1374b278c3"></a>
stringVector&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsCStringColumnVector</b> (void) const </td></tr>
<tr class="separator:aa4cc4e7a4d441fb9f06dcb1374b278c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d473bedf208c01e3705fff9b777dfe"><td class="memItemLeft" align="right" valign="top">logical&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a79d473bedf208c01e3705fff9b777dfe">getContentAsLogicalScalar</a> () const </td></tr>
<tr class="separator:a79d473bedf208c01e3705fff9b777dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6362dca40c071eb8ea5905d12769ed63"><td class="memItemLeft" align="right" valign="top">int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a6362dca40c071eb8ea5905d12769ed63">getContentAsInteger8Scalar</a> ()</td></tr>
<tr class="separator:a6362dca40c071eb8ea5905d12769ed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f740f3c80b63b1f0f29f816790bcf1"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ac0f740f3c80b63b1f0f29f816790bcf1">getContentAsUnsignedInteger8Scalar</a> ()</td></tr>
<tr class="separator:ac0f740f3c80b63b1f0f29f816790bcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b178c1df35cf2d003692dcb3676883b"><td class="memItemLeft" align="right" valign="top">int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a2b178c1df35cf2d003692dcb3676883b">getContentAsInteger16Scalar</a> ()</td></tr>
<tr class="separator:a2b178c1df35cf2d003692dcb3676883b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66444a5cbbf8d7f9dd57921c89a4ea"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a7e66444a5cbbf8d7f9dd57921c89a4ea">getContentAsUnsignedInteger16Scalar</a> ()</td></tr>
<tr class="separator:a7e66444a5cbbf8d7f9dd57921c89a4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9557a773f9a3edd96cf237708f08ddd0"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9557a773f9a3edd96cf237708f08ddd0">getContentAsInteger32Scalar</a> ()</td></tr>
<tr class="separator:a9557a773f9a3edd96cf237708f08ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f599bb4f6c58add650109fbaba00d17"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a2f599bb4f6c58add650109fbaba00d17">getContentAsUnsignedInteger32Scalar</a> ()</td></tr>
<tr class="separator:a2f599bb4f6c58add650109fbaba00d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f1b46eaf0997dc8eabdd391ceed1d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a91f1b46eaf0997dc8eabdd391ceed1d6">getContentAsDoubleScalar</a> ()</td></tr>
<tr class="separator:a91f1b46eaf0997dc8eabdd391ceed1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ca10919075f5371ff97dfad7381f0"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#abb2ca10919075f5371ff97dfad7381f0">getContentAsUnsignedInt64Scalar</a> ()</td></tr>
<tr class="separator:abb2ca10919075f5371ff97dfad7381f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780de0c4320500601fe3f61380dec0a"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9780de0c4320500601fe3f61380dec0a">getContentAsInteger64Scalar</a> ()</td></tr>
<tr class="separator:a9780de0c4320500601fe3f61380dec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd6a8ea9e3766963eb85ff42125b1e9"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aefd6a8ea9e3766963eb85ff42125b1e9">getContentAsScalarIndex</a> (bool bWithZero=true)</td></tr>
<tr class="separator:aefd6a8ea9e3766963eb85ff42125b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e882086978325362bf0dfd1b5dbaf21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e882086978325362bf0dfd1b5dbaf21"></a>
indexType *&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsIndexPointer</b> ()</td></tr>
<tr class="separator:a1e882086978325362bf0dfd1b5dbaf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52045ffd66caa96b4ea4f60bec71a7c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdoublecomplex.html">doublecomplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a52045ffd66caa96b4ea4f60bec71a7c4">getContentAsDoubleComplexScalar</a> ()</td></tr>
<tr class="separator:a52045ffd66caa96b4ea4f60bec71a7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e84e898beb86a7179b0f244bef0c9b"><td class="memItemLeft" align="right" valign="top">single&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a21e84e898beb86a7179b0f244bef0c9b">getContentAsSingleScalar</a> ()</td></tr>
<tr class="separator:a21e84e898beb86a7179b0f244bef0c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d105ca2a15d18acff11f627bd7ea6b"><td class="memItemLeft" align="right" valign="top">std::complex&lt; single &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a36d105ca2a15d18acff11f627bd7ea6b">getContentAsSingleComplexScalar</a> ()</td></tr>
<tr class="separator:a36d105ca2a15d18acff11f627bd7ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a98b97055d61958d0b272f5505187"><td class="memItemLeft" align="right" valign="top">indexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a816a98b97055d61958d0b272f5505187">nnz</a> ()</td></tr>
<tr class="separator:a816a98b97055d61958d0b272f5505187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5289e7744597e0e9743dfe038df6be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba5289e7744597e0e9743dfe038df6be"></a>
indexType&#160;</td><td class="memItemRight" valign="bottom"><b>nzmax</b> ()</td></tr>
<tr class="separator:aba5289e7744597e0e9743dfe038df6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f9263af99589ae2136e05fe3a8603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d6f9263af99589ae2136e05fe3a8603"></a>
indexType&#160;</td><td class="memItemRight" valign="bottom"><b>numel</b> ()</td></tr>
<tr class="separator:a5d6f9263af99589ae2136e05fe3a8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d49c1d04b06240acbf0b8cf09febe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d49c1d04b06240acbf0b8cf09febe3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCell</b> ()</td></tr>
<tr class="separator:a62d49c1d04b06240acbf0b8cf09febe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ffba95e2aa6a4376b930880b315fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b9ffba95e2aa6a4376b930880b315fb"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStruct</b> () const </td></tr>
<tr class="separator:a6b9ffba95e2aa6a4376b930880b315fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4c096e23c87fcadc68b14bd8ba44e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd4c096e23c87fcadc68b14bd8ba44e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStructType</b> (std::string structname)</td></tr>
<tr class="separator:acd4c096e23c87fcadc68b14bd8ba44e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcedf94b23476ca8e56649d5a1efcbff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcedf94b23476ca8e56649d5a1efcbff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStructType</b> (std::wstring structname)</td></tr>
<tr class="separator:afcedf94b23476ca8e56649d5a1efcbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca400593173b6e47d581a4cff2073c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafca400593173b6e47d581a4cff2073c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getStructType</b> () const </td></tr>
<tr class="separator:aafca400593173b6e47d581a4cff2073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b303c691f165b580dd5d179311f2c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22b303c691f165b580dd5d179311f2c0"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isClassStruct</b> () const </td></tr>
<tr class="separator:a22b303c691f165b580dd5d179311f2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09781bc31bcd8e38016566b71d913d7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09781bc31bcd8e38016566b71d913d7e"></a>
function_handle&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsFunctionHandle</b> ()</td></tr>
<tr class="separator:a09781bc31bcd8e38016566b71d913d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c8eb8023b70bc8cce68ae4d150ad56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26c8eb8023b70bc8cce68ae4d150ad56"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFunctionHandle</b> ()</td></tr>
<tr class="separator:a26c8eb8023b70bc8cce68ae4d150ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53adca0a7e115f3dbbf44dce72b8dccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53adca0a7e115f3dbbf44dce72b8dccf"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLogical</b> () const </td></tr>
<tr class="separator:a53adca0a7e115f3dbbf44dce72b8dccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c443e812d0e823a7215f75848a01b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93c443e812d0e823a7215f75848a01b"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNdArrayLogical</b> () const </td></tr>
<tr class="separator:aa93c443e812d0e823a7215f75848a01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add141cd00093d46cb17414d962b93d17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add141cd00093d46cb17414d962b93d17"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLogicalSparseType</b> () const </td></tr>
<tr class="separator:add141cd00093d46cb17414d962b93d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea90106480ab2f2615d4b58e2433cf44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea90106480ab2f2615d4b58e2433cf44"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNumeric</b> () const </td></tr>
<tr class="separator:aea90106480ab2f2615d4b58e2433cf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3808c5587783b83ba40feb58afc9d1e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3808c5587783b83ba40feb58afc9d1e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scalarToMatrix</b> (<a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> newDimensions)</td></tr>
<tr class="separator:a3808c5587783b83ba40feb58afc9d1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b8ed2670168f0fba04a5c8b3d874e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1b8ed2670168f0fba04a5c8b3d874e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteArrayOf</b> (void *dp, Class dataclass)</td></tr>
<tr class="separator:ae1b8ed2670168f0fba04a5c8b3d874e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d5d7740f31df7c5216c33867090dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c0d5d7740f31df7c5216c33867090dd"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHandle</b> () const </td></tr>
<tr class="separator:a5c0d5d7740f31df7c5216c33867090dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0233ed8ef7236b5bd8a150612a087080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0233ed8ef7236b5bd8a150612a087080"></a>
<a class="el" href="class_nelson_1_1_handle_generic_object.html">HandleGenericObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getContentAsHandleScalar</b> ()</td></tr>
<tr class="separator:a0233ed8ef7236b5bd8a150612a087080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6db61748b1eb864a3dbb09952fcb38d2"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a6db61748b1eb864a3dbb09952fcb38d2">allocateArrayOf</a> (Class, indexType length, const stringVector &amp;names=stringVector(), bool initializeValues=true)</td></tr>
<tr class="separator:a6db61748b1eb864a3dbb09952fcb38d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39ad2a17e55decf45ffef229178086f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#af39ad2a17e55decf45ffef229178086f">diagonalConstructor</a> (<a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> src, int diagonalOrder)</td></tr>
<tr class="separator:af39ad2a17e55decf45ffef229178086f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a613eca0888bdf0f07f112b6add495f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9a613eca0888bdf0f07f112b6add495f">emptyConstructor</a> (<a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> dim, bool bIsSparse=false)</td></tr>
<tr class="separator:a9a613eca0888bdf0f07f112b6add495f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd30330f8d2c7ad55a4c69a505d919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34bd30330f8d2c7ad55a4c69a505d919"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyConstructor</b> (indexType m=0, indexType n=0, bool bIsSparse=false)</td></tr>
<tr class="separator:a34bd30330f8d2c7ad55a4c69a505d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2134f26750762813ec1b0ee1a6c05b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aa2134f26750762813ec1b0ee1a6c05b9">logicalConstructor</a> (bool aval)</td></tr>
<tr class="separator:aa2134f26750762813ec1b0ee1a6c05b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ce2027ec7e3cb574d804b60ccf602"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a4c7ce2027ec7e3cb574d804b60ccf602">uint8Constructor</a> (uint8 aval)</td></tr>
<tr class="separator:a4c7ce2027ec7e3cb574d804b60ccf602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6ed9369a253a43a007379d498a4384"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9b6ed9369a253a43a007379d498a4384">int8Constructor</a> (int8 aval)</td></tr>
<tr class="separator:a9b6ed9369a253a43a007379d498a4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f3a43644273fec3a1c413f4364e8d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a21f3a43644273fec3a1c413f4364e8d2">uint16Constructor</a> (uint16 aval)</td></tr>
<tr class="separator:a21f3a43644273fec3a1c413f4364e8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a263244a7af084ff0f8dafe5ce98cda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a7a263244a7af084ff0f8dafe5ce98cda">int16Constructor</a> (int16 aval)</td></tr>
<tr class="separator:a7a263244a7af084ff0f8dafe5ce98cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b62387aec45cfc89997026795dac456"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9b62387aec45cfc89997026795dac456">uint32Constructor</a> (uint32 aval)</td></tr>
<tr class="separator:a9b62387aec45cfc89997026795dac456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cf06ccf81019f635204210c02f0e56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ae8cf06ccf81019f635204210c02f0e56">int32Constructor</a> (int32 aval)</td></tr>
<tr class="separator:ae8cf06ccf81019f635204210c02f0e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b522c22a2b049ad21f700732e41ddfb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a1b522c22a2b049ad21f700732e41ddfb">uint64Constructor</a> (uint64 aval)</td></tr>
<tr class="separator:a1b522c22a2b049ad21f700732e41ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d507b159d9faf5d85f718c493fdb3b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9d507b159d9faf5d85f718c493fdb3b8">int64Constructor</a> (int64 aval)</td></tr>
<tr class="separator:a9d507b159d9faf5d85f718c493fdb3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739af3e2f0acce90a27ed421727e0bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#af739af3e2f0acce90a27ed421727e0bd">singleConstructor</a> (float aval)</td></tr>
<tr class="separator:af739af3e2f0acce90a27ed421727e0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1405b98c989e7f724693826998154"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aedd1405b98c989e7f724693826998154">doubleConstructor</a> (double aval)</td></tr>
<tr class="separator:aedd1405b98c989e7f724693826998154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20567a4057dc6d12b26ad5138a110a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a0e20567a4057dc6d12b26ad5138a110a">complexConstructor</a> (float aval, float bval)</td></tr>
<tr class="separator:a0e20567a4057dc6d12b26ad5138a110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b980a458c67f56f096c59c44abf0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a410b980a458c67f56f096c59c44abf0f">dcomplexConstructor</a> (double aval, double bval)</td></tr>
<tr class="separator:a410b980a458c67f56f096c59c44abf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecb17d6702c4f4ea1204f57ada32dd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a2ecb17d6702c4f4ea1204f57ada32dd1">stringConstructor</a> (std::string aval)</td></tr>
<tr class="separator:a2ecb17d6702c4f4ea1204f57ada32dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e92cc13e404cfd4c0f7852a6a0fb51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#ac2e92cc13e404cfd4c0f7852a6a0fb51">stringConstructor</a> (std::wstring aval)</td></tr>
<tr class="separator:ac2e92cc13e404cfd4c0f7852a6a0fb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7be218e939f5a1449881030f4da6f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a4fa7be218e939f5a1449881030f4da6f">int64VectorConstructor</a> (int len)</td></tr>
<tr class="separator:a4fa7be218e939f5a1449881030f4da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517064f1d9fe22051610f8be84d26ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a1517064f1d9fe22051610f8be84d26ea">int32VectorConstructor</a> (int len)</td></tr>
<tr class="separator:a1517064f1d9fe22051610f8be84d26ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5393781f20a9c3c4d0e4903d910e64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aac5393781f20a9c3c4d0e4903d910e64">doubleVectorConstructor</a> (int len)</td></tr>
<tr class="separator:aac5393781f20a9c3c4d0e4903d910e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3bbc9484f58e9f3800824b153967e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a68c3bbc9484f58e9f3800824b153967e">int32Matrix2dConstructor</a> (indexType m, indexType n)</td></tr>
<tr class="separator:a68c3bbc9484f58e9f3800824b153967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723a3f240b75b3fff500cbc9b2bfd11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a2723a3f240b75b3fff500cbc9b2bfd11">doubleMatrix2dConstructor</a> (indexType m, indexType n)</td></tr>
<tr class="separator:a2723a3f240b75b3fff500cbc9b2bfd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf4749c57e1198cad3fc76a71c34e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a8baf4749c57e1198cad3fc76a71c34e0">integerRangeConstructor</a> (indexType minval, indexType stepsize, indexType maxval, bool vertical)</td></tr>
<tr class="separator:a8baf4749c57e1198cad3fc76a71c34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be6f2ac7b731937fa318a741445160"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aa1be6f2ac7b731937fa318a741445160">cellConstructor</a> (ArrayOfMatrix &amp;m)</td></tr>
<tr class="separator:aa1be6f2ac7b731937fa318a741445160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae12d72e2bdd7616798b21bbd1d93c55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#aae12d72e2bdd7616798b21bbd1d93c55">structConstructor</a> (stringVector fNames, ArrayOfVector &amp;values)</td></tr>
<tr class="separator:aae12d72e2bdd7616798b21bbd1d93c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2fbd9bf4e85bb4cf9b23c5f19479b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e2fbd9bf4e85bb4cf9b23c5f19479b1"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>structConstructor</b> (wstringVector fNames, ArrayOfVector &amp;values)</td></tr>
<tr class="separator:a9e2fbd9bf4e85bb4cf9b23c5f19479b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb475a37dd0538b3418e4ce0c394836"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eb475a37dd0538b3418e4ce0c394836"></a>
static ArrayOfVector&#160;</td><td class="memItemRight" valign="bottom"><b>emptyStructWithoutFields</b> ()</td></tr>
<tr class="separator:a2eb475a37dd0538b3418e4ce0c394836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27a25f435831d87df0cd7e7762825c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af27a25f435831d87df0cd7e7762825c4"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyStructConstructor</b> (stringVector fNames, <a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> dim)</td></tr>
<tr class="separator:af27a25f435831d87df0cd7e7762825c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a966a7dda4a58a07c23d424b3ae54d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64a966a7dda4a58a07c23d424b3ae54d"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyStructConstructor</b> (wstringVector fNames, <a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> dim)</td></tr>
<tr class="separator:a64a966a7dda4a58a07c23d424b3ae54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c1cefeba9b295d530392fd5b73e4a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a9b3c1cefeba9b295d530392fd5b73e4a">isDataClassReferenceType</a> (Class)</td></tr>
<tr class="separator:a9b3c1cefeba9b295d530392fd5b73e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a04a24d76151fdb9b41c9b3f9d918d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a8a04a24d76151fdb9b41c9b3f9d918d2">setArrayOfIOInterface</a> (<a class="el" href="class_nelson_1_1_interface.html">Interface</a> *io)</td></tr>
<tr class="separator:a8a04a24d76151fdb9b41c9b3f9d918d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611991801285faa89f6a390d4afbc8a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nelson_1_1_interface.html">Interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nelson_1_1_array_of.html#a611991801285faa89f6a390d4afbc8a6">getArrayOfIOInterface</a> ()</td></tr>
<tr class="separator:a611991801285faa89f6a390d4afbc8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64751f6df8de7321575320249d61d1ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64751f6df8de7321575320249d61d1ba"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>functionHandleConstructor</b> (std::wstring functionName, function_handle fptr)</td></tr>
<tr class="separator:a64751f6df8de7321575320249d61d1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fd54b48273d7d12bbc5e582eeb0fd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7fd54b48273d7d12bbc5e582eeb0fd8"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>handleConstructor</b> (<a class="el" href="class_nelson_1_1_handle_generic_object.html">HandleGenericObject</a> *ptr)</td></tr>
<tr class="separator:ac7fd54b48273d7d12bbc5e582eeb0fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce26e1ed4494827f3f4152e6b724b38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abce26e1ed4494827f3f4152e6b724b38"></a>
static <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>handleConstructor</b> (nelson_handle hl)</td></tr>
<tr class="separator:abce26e1ed4494827f3f4152e6b724b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Ordered data array, the base <a class="el" href="namespace_nelson.html">Nelson</a> data type. The <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> class is the base class of all data types. It represents an ordered collection of data, indexed using an arbitrary number of dimensions. The <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> class uses a seperate data class to store the data. It can contain an N-dimensional array of any of the following data types:</p><ul>
<li>NLS_HANDLE</li>
<li>NLS_CELL_ARRAY - a heterogenous array - essentially an array of ArrayOfs</li>
<li>NLS_STRUCT_ARRAY - a structure array</li>
<li>NLS_UINT8 - unsigned, 8-bit integers</li>
<li>NLS_INT8 - signed, 8-bit integers</li>
<li>NLS_UINT16 - unsigned, 16-bit integers</li>
<li>NLS_INT16 - signed, 16-bit integers</li>
<li>NLS_UINT32 - unsigned, 32-bit integers</li>
<li>NLS_INT32 - signed, 32-bit integers</li>
<li>NLS_SINGLE - 32-bit floating point</li>
<li>NLS_DOUBLE - 64-bit floating point</li>
<li>NLS_SCOMPLEX - 32-bit complex floating point</li>
<li>NLS_DCOMPLEX - 64-bit complex floating point</li>
<li>NLS_CHAR - a string class</li>
</ul>
<p>The <a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> class is used to record the dimensions of the given <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. The Dimension class represents an n-tuple of integers that record the number of elements along the array in each dimension. The data is stored in a generalization of "column-major" order. Note that the array class does <em>not</em> actually include the data - the data is stored in the <a class="el" href="class_nelson_1_1_data.html">Data</a> class, to which <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> contains a pointer. This design allows for rapid copying of <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> objects. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac7a72e0db830056c46ef8ea9dab24e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nelson::ArrayOf::ArrayOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a1d78abac9c4b66126f5010deea512a7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nelson::ArrayOf::ArrayOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="aee7cbe5880d62fbb33696602150a80c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nelson::ArrayOf::ArrayOf </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an empty <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> of the specified type. </p>

</div>
</div>
<a class="anchor" id="abe51353747bb5c554dcebd4f8e94ecb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nelson::ArrayOf::ArrayOf </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringVector &amp;&#160;</td>
          <td class="paramname"><em>fnames</em> = <code>stringVector()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> with the specified contents.</p>
<p>Create a variable with the specified contents. </p>

</div>
</div>
<a class="anchor" id="a33dace5f733c845dcedb3db33918a6e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nelson::ArrayOf::~ArrayOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor - free the data object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6db61748b1eb864a3dbb09952fcb38d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Nelson::ArrayOf::allocateArrayOf </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stringVector &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>stringVector()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initializeValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate an array. </p>

</div>
</div>
<a class="anchor" id="ab07efba2fd634afec74e730db0f73e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::allReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if all values are real. </p>

</div>
</div>
<a class="anchor" id="aa1be6f2ac7b731937fa318a741445160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::cellConstructor </td>
          <td>(</td>
          <td class="paramtype">ArrayOfMatrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor for a cell array is significantly simpler than the matrix constructor. The argument is a list of rowdefs. Each element in the rowdef is a <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> pointer that we assign to our data pointer. The only thing we need to make sure of is that each row has the same number of elements in it. Throws an exception if the geometry of the argumens is incompatible. </p>
<p>If this is the first row in the matrix def, then we record its size in columnCount.</p>
<p>Otherwise, make sure the column counts are all the same...</p>
<p>At this point, we know how many columns our cell array has, and the number of rows is also known (size of m). So, set up our dimensions, and allocate the output.</p>
<p>Allocate storage space for the contents.</p>
<p>Loop through the rows.</p>

</div>
</div>
<a class="anchor" id="a0e20567a4057dc6d12b26ad5138a110a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::complexConstructor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complex constructor - Construct an NLS_SCOMPLEX object with a complex scalar value. </p>

</div>
</div>
<a class="anchor" id="adfab244ba48990a447b1ae10fe61ff24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::copyElements </td>
          <td>(</td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from our data array to the specified array. This is a deep copy, in the sense that pointers are copied by creating new objects. Copy count elements, starting at index srcIndex to the destination address starting at index dstIndex. The addresses are in terms of indices, not bytes. </p>

</div>
</div>
<a class="anchor" id="a410b980a458c67f56f096c59c44abf0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::dcomplexConstructor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>aval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complex constructor - Construct an NLS_DCOMPLEX object with a complex scalar value. </p>

</div>
</div>
<a class="anchor" id="ab26b16a2e6646d2c7c5420b53309901b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::deleteNDimSubset </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a subset of this array using the arguments for n-Dimensional indexing. This method is the "planar" delete, meaning that its designed to delete all the entries in an N-ary array in one dimension. It cannot be used to create "holes" in an array. Throws an exception if the argument contains more than one non-colon index</p>
<p>Delete a subset of a variable. </p>

</div>
</div>
<a class="anchor" id="a7d8a5194e72bc298d250c808b5979dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::deleteVectorSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a subset of this array using the argument for vector indexing. This is <em>much</em> simpler than the planar case. Here, we simply:</p><ul>
<li>Create a deletion map from the index variable.</li>
<li>Adjust the size of the output, and reshape to a vector.</li>
<li>Copy (and skip) as necessary. The result is then resized using the same rules as in vectorResize.</li>
</ul>
<p>Delete a vector subset of a variable. </p>

</div>
</div>
<a class="anchor" id="af39ad2a17e55decf45ffef229178086f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::diagonalConstructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diagonalOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Diagonal constructor - construct an array from a given vector, with the contents of the vector stored into the specified diagonal of the matrix. Throwsn an exception if the argument is not a vector. </p>

</div>
</div>
<a class="anchor" id="aedd1405b98c989e7f724693826998154"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::doubleConstructor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_DOUBLE object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a2723a3f240b75b3fff500cbc9b2bfd11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::doubleMatrix2dConstructor </td>
          <td>(</td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double matrix constructor - Construct an NLS_DOUBLE object that is a (row, columns) matrix with the given length. </p>

</div>
</div>
<a class="anchor" id="aac5393781f20a9c3c4d0e4903d910e64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::doubleVectorConstructor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double vector constructor - Construct an NLS_DOUBLE object that is a (row) vector with the given length. </p>

</div>
</div>
<a class="anchor" id="a9a613eca0888bdf0f07f112b6add495f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::emptyConstructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsSparse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empty constructor </p>

</div>
</div>
<a class="anchor" id="a829e7c989b5a76a48e35a52b02265203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::ensureSingleOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure we have at most one owner for our data - allows us to modify the data without affecting other arrays. </p>

</div>
</div>
<a class="anchor" id="a611991801285faa89f6a390d4afbc8a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_interface.html">Interface</a> * Nelson::ArrayOf::getArrayOfIOInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the IO interface being used by instances of the <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> class. </p>

</div>
</div>
<a class="anchor" id="a702d62df7e115010bcb463aed16c9d84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::getByteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bytes required to hold this array (element size * length)</p>
<p>Calculate the total number of bytes required to store this array. </p>

</div>
</div>
<a class="anchor" id="ae5319308233d81b5ea169b4380b8b734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Nelson::ArrayOf::getContentAsCString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a C-string (UTF-8). Only works for STRING types. Throws an exception for non-string types. </p>

</div>
</div>
<a class="anchor" id="a52045ffd66caa96b4ea4f60bec71a7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdoublecomplex.html">doublecomplex</a> Nelson::ArrayOf::getContentAsDoubleComplexScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a double complex scalar. Throws an exception if we are not scalar or cannot meaningfully be converted to a double precision value. </p>

</div>
</div>
<a class="anchor" id="a91f1b46eaf0997dc8eabdd391ceed1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Nelson::ArrayOf::getContentAsDoubleScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a double scalar. Throws an exception if we are not scalar or cannot meaningfully be converted to a double precision value. </p>

</div>
</div>
<a class="anchor" id="a2b178c1df35cf2d003692dcb3676883b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16 Nelson::ArrayOf::getContentAsInteger16Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an integer scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a9557a773f9a3edd96cf237708f08ddd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 Nelson::ArrayOf::getContentAsInteger32Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an integer scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a9780de0c4320500601fe3f61380dec0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 Nelson::ArrayOf::getContentAsInteger64Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an integer scalar 64. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a6362dca40c071eb8ea5905d12769ed63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8 Nelson::ArrayOf::getContentAsInteger8Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an integer 8 bits scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a79d473bedf208c01e3705fff9b777dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical Nelson::ArrayOf::getContentAsLogicalScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an logical scalar. Throws an exception if we are not a scalar logical type. </p>

</div>
</div>
<a class="anchor" id="aefd6a8ea9e3766963eb85ff42125b1e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::getContentAsScalarIndex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWithZero</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a index type scalar. Throws an exception if we are not scalar or cannot meaningfully be converted to a index typevalue. </p>

</div>
</div>
<a class="anchor" id="a36d105ca2a15d18acff11f627bd7ea6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; single &gt; Nelson::ArrayOf::getContentAsSingleComplexScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a single complex scalar. Throws an exception if we are not scalar or cannot meaningfully be converted to a single precision value. </p>

</div>
</div>
<a class="anchor" id="a21e84e898beb86a7179b0f244bef0c9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">single Nelson::ArrayOf::getContentAsSingleScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a float scalar. Throws an exception if we are not scalar or cannot meaningfully be converted to a double precision value. </p>

</div>
</div>
<a class="anchor" id="abb2ca10919075f5371ff97dfad7381f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 Nelson::ArrayOf::getContentAsUnsignedInt64Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an unsigned integer scalar 64. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a7e66444a5cbbf8d7f9dd57921c89a4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 Nelson::ArrayOf::getContentAsUnsignedInteger16Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an unsigned integer scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="a2f599bb4f6c58add650109fbaba00d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 Nelson::ArrayOf::getContentAsUnsignedInteger32Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an unsigned integer scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="ac0f740f3c80b63b1f0f29f816790bcf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 Nelson::ArrayOf::getContentAsUnsignedInteger8Scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as an unsigned integer 8 bits scalar. Throws an exception if we are not a scalar integer type. </p>

</div>
</div>
<a class="anchor" id="acb2b3f698b01295e68f76e26c6fd464b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring Nelson::ArrayOf::getContentAsWideString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a wide string (UTF-16). Only works for STRING types. Throws an exception for non-string types. </p>

</div>
</div>
<a class="anchor" id="a875b8f92049fa13075586a29df40d7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstringVector Nelson::ArrayOf::getContentAsWideStringColumnVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a vector wide string (UTF-16). Only works for CELL of STRING types. Check if it is a cell with a column vector dimension </p>

</div>
</div>
<a class="anchor" id="a9f2f020fe30149a63634055a49b793dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstringVector Nelson::ArrayOf::getContentAsWideStringRowVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a vector wide string (UTF-16). Only works for CELL of STRING types. Check if it is a cell with a row vector dimension </p>

</div>
</div>
<a class="anchor" id="acadbec4dd6b43bc0e788d4ec4472d00f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wstringVector Nelson::ArrayOf::getContentAsWideStringVector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCheckVector</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our contents as a vector wide string (UTF-16). Only works for CELL of STRING types. no check on dimensions </p>

</div>
</div>
<a class="anchor" id="aeded4de7723da708811252fbbf473406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Class Nelson::ArrayOf::getDataClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our data class (of type Class). </p>

</div>
</div>
<a class="anchor" id="ad2c7816ab1b0d6aa266f9dadeb2530b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * Nelson::ArrayOf::getDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the contents of our data block as a (read-only) void* pointer. Get the contents of our data block as a void* pointer. The resulting pointer is read only, so that no modifications can be made to the contents of our array. To modify the contents, you must make a copy and use setDataPointer to replace the current data. This "copy-on-write" technique avoids copies on references to variables &ndash; a good thing in this interpreted environment where read-references dominate the accesses to variables. Another option is to use getReadWriteDataPointer, which returns a pointer that is free of object aliases. </p>

</div>
</div>
<a class="anchor" id="aae5ca93ea1ba2691872bdfb55eebfa49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::getDimensionLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get our length along the given dimension. </p>

</div>
</div>
<a class="anchor" id="aef10e3aa095b78fdb602e453ed1f4d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> Nelson::ArrayOf::getDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a copy of our dimensions vector. </p>

</div>
</div>
<a class="anchor" id="a6417d5a73a619e7b715d72e80227f260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::getElementSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the size of each element in this array. </p>

</div>
</div>
<a class="anchor" id="afa5401338db1279ea48504f3fb75544c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getField </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the contents of a field from its field name. Again, like getVectorContents and getNDimContents, this function is meant for assignments only, and the argument must be a scalar structure. Throws an exection if we are a vector, or if the supplied field do not exist. </p>

</div>
</div>
<a class="anchor" id="aa3ce3b60e66c2872361d28f1c82bdc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOfVector Nelson::ArrayOf::getFieldAsList </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the contents of a field as an array from its field name. This is used when a structure array is used to supply a list of expressions. Throws an exception if</p><ul>
<li>we are not a structure array</li>
<li>the field does not exist </li>
</ul>

</div>
</div>
<a class="anchor" id="a373e06286130d08962da5cb197519b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stringVector Nelson::ArrayOf::getFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the fieldnames. </p>

</div>
</div>
<a class="anchor" id="a0d29b68719440347d24eaad1bb772789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length of the array as a vector. This is equivalent to computing length(this(:)). </p>

</div>
</div>
<a class="anchor" id="a40da3e09837c3479e3cd5cd32979aab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getNDimContents </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>indexing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-addressing. This is for NDim- indexing, meaning that the argument is assumed to refer to the elements in their N-Dimensional: meaning that x{10} is really x{10,1}. Like getVectorContents, this function is meant for assignments only. Throws an exception if</p><ul>
<li>we are not a cell array</li>
<li>the indices do not define a single value</li>
</ul>
<p>Return the contents of a cell array - indexed via a multi-dim index. </p>

</div>
</div>
<a class="anchor" id="a6851a8bd83c9f69960af6a0747d27e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOfVector Nelson::ArrayOf::getNDimContentsAsList </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-addressing. This is used when a cell array is used to supply a list of expressions. Throws an exception if we are not a cell-array.</p>
<p>Return the contents of an cell array as a list. </p>

</div>
</div>
<a class="anchor" id="aefd61022a590f59e438c9f4a68da4da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getNDimSubset </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. This if for n-Dimensional-indexing, meaning that x(10) is really x(10,1). Throws an exception if the variable is empty.</p>
<p>Take the current variable, and return a new array consisting of the elements in source indexed by the index argument. Indexing is done using ndimensional indices. </p>

</div>
</div>
<a class="anchor" id="a59ad4fb5d10fbabf71395778e1d72345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Nelson::ArrayOf::getReadWriteDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the contents of our data block as a read-write void* pointer. Get the contents of our data block as a read-write void* pointer. It ensures that our data block is not aliased (meaning that no other array objects share the data block), prior to returning the pointer. To do this, we have to go through the following steps:</p><ul>
<li>Check the number of owners of our byte array.</li>
<li>If there is only one owner for the byte array, return a non-const pointer to the data</li>
<li>If there is more than one owner, copy our data. </li>
</ul>

</div>
</div>
<a class="anchor" id="afbcbd81425f3f709a9f8b2ec05247d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Nelson::ArrayOf::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference count to our data object - useful for debug purposes. </p>

</div>
</div>
<a class="anchor" id="a18e48b1a0fbbfad999d9748e85a914c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getValueAtIndex </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns value as an array =A(index) simple extraction (fast used 'for' loop) </p>

</div>
</div>
<a class="anchor" id="ac9c691f165c485b98797efe087ab2d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getVectorContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>indexing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-addressing. This is for vector- indexing, meaning that the argument is assumed to refer to the elements in their order as a vector. So, x{10} is equivalent to x(:){10}, even if, say, x is 3 x 4. This function is only used in assignment calls of the form e.g., a{10} = 5. The vector argument must therefor be a scalar. Throws an exception if</p><ul>
<li>we are not a cell array</li>
<li>the argument is empty</li>
<li>the argument defines more than a single value</li>
<li>the index exceeds the bounds of the array.</li>
</ul>
<p>Return the contents of a cell array - must be a scalar... </p>

</div>
</div>
<a class="anchor" id="a96ba1f8d0c89eb7f6c1a730067689be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayOfVector Nelson::ArrayOf::getVectorContentsAsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of a (cell) <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-addressing. This is used when a cell array is used to supply a list of expressions. Throws an exception if</p><ul>
<li>we are not a cell-array</li>
<li>the indices exceed the array bounds</li>
</ul>
<p>Return a subset of a cell array as a list. </p>

</div>
</div>
<a class="anchor" id="a884c77dbdff80afc89c2f6742bcc5162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::getVectorSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. This is for vector-indexing, meaning that the argument is assumed to refer to the elements in their order as a vector. So, x(10) is equivalent to x(:)(10), even if, say, x is 3 x 4. Throws an exception if</p><ul>
<li>the variable is empty</li>
<li>the argument subset exceeds our valid domain</li>
</ul>
<p>Take the current variable, and return a new array consisting of the elements in source indexed by the index argument. Indexing is done using vector ordinals. </p>

</div>
</div>
<a class="anchor" id="a7a263244a7af084ff0f8dafe5ce98cda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int16Constructor </td>
          <td>(</td>
          <td class="paramtype">int16&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_INT16 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="ae8cf06ccf81019f635204210c02f0e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int32Constructor </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_INT32 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a68c3bbc9484f58e9f3800824b153967e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int32Matrix2dConstructor </td>
          <td>(</td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>int32 matrix constructor - Construct an NLS_INT32 object that is a (row, columns) matrix with the given length. </p>

</div>
</div>
<a class="anchor" id="a1517064f1d9fe22051610f8be84d26ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int32VectorConstructor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>int32 vector constructor - Construct an NLS_INT32 object that is a (row) vector with the given length. </p>

</div>
</div>
<a class="anchor" id="a9d507b159d9faf5d85f718c493fdb3b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int64Constructor </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_INT64 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a4fa7be218e939f5a1449881030f4da6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int64VectorConstructor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>int64 vector constructor - Construct an NLS_INT64 object that is a (row) vector with the given length. </p>

</div>
</div>
<a class="anchor" id="a9b6ed9369a253a43a007379d498a4384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::int8Constructor </td>
          <td>(</td>
          <td class="paramtype">int8&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_INT8 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a8baf4749c57e1198cad3fc76a71c34e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::integerRangeConstructor </td>
          <td>(</td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>stepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vertical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a NLS_INT32 or NLS_INT64 (on x64 platform) vector (either vertical or horizontal) corresponding to minval:stepsize:maxval, with an optional transpose. </p>

</div>
</div>
<a class="anchor" id="a51a013e67d796f159d5ef9a9de68dfc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::is2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are 2-Dimensional. </p>

</div>
</div>
<a class="anchor" id="a221309ca0f64bd2177769b1e7ab68915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isComplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a complex data type. </p>

</div>
</div>
<a class="anchor" id="a9b3c1cefeba9b295d530392fd5b73e4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Nelson::ArrayOf::isDataClassReferenceType </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given Class is either NLS_CELL_ARRAY or NLS_STRUCT_ARRAY. </p>

</div>
</div>
<a class="anchor" id="ae8c734ea55e9ac3d5ef17bb195ae450c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isDoubleSparseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a sparse double or complex data type.</p>
<p>Returns TRUE if it is a double type (not ndarray, not sparse) </p>

</div>
</div>
<a class="anchor" id="a3bad2aace887b8e8586400f3b5d2cb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isDoubleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if it is a ndarraydouble type (not sparse, not scalar, 2D matrix) </p>

</div>
</div>
<a class="anchor" id="a71313e6b6ae0374803228677cd86a9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isEmpty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allDimensionsIsZero</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are empty (we have no elements). </p>

</div>
</div>
<a class="anchor" id="a031e9072159be4b86ed517f6906e9c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isNdArrayDoubleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if it is a double type (not ndarray, not sparse) </p>

</div>
</div>
<a class="anchor" id="adff4ca799bce96f352134aea30623f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isNdArraySingleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if it is a ndarraydouble type (not sparse, not scalar, 2D matrix) </p>

</div>
</div>
<a class="anchor" id="a1982cea81188dbeb7eeb9516e633f5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isPositive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we are (meaningfully) positive. For the unsigned integer types, this is always true. For complex types, this is false. For the signed integer types or the floating point types, the result is based on a linear scan through the array. </p>

</div>
</div>
<a class="anchor" id="af3f8cd00ed880539770408d0b6450762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a real data type. </p>

</div>
</div>
<a class="anchor" id="af3edf314c6de3d9a3d196b511f1b22a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isRealAllZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if our real part is all zeros. For integer types, this is an element-wise test. For complex types, we check only the real part. Throws an exception if we are a string, cell-array or struct-array type. </p>

</div>
</div>
<a class="anchor" id="a929aba4235e243bee8985990d8e8614c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isReferenceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a reference type (cell array or struct array). </p>

</div>
</div>
<a class="anchor" id="a618f2a55d70eb97387c8d7101aaf83dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we have only a single element. </p>

</div>
</div>
<a class="anchor" id="a0ce2f1f165d537bf09faffeeedf548a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isSingleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if it is a double type (not ndarray, not sparse)</p>
<p>Returns TRUE if it is a single type (not ndarray, not sparse) </p>

</div>
</div>
<a class="anchor" id="a022cd4577944fb1a3d61f2ce454723aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are 2-Dimensional and rows == cols.</p>
<p>Returns TRUE if we are 2-Dimensional and cols == rows. </p>

</div>
</div>
<a class="anchor" id="a827f47d84a1bbb1c65f9c74bd0fcdbf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a string. </p>

</div>
</div>
<a class="anchor" id="a60614f939042f9214550864d9c70199a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::isVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if we are a vector. </p>

</div>
</div>
<a class="anchor" id="aa2134f26750762813ec1b0ee1a6c05b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::logicalConstructor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_LOGICAL object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a816a98b97055d61958d0b272f5505187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexType Nelson::ArrayOf::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of nonzero elements in the array. For reference types, this is a best-guess. </p>

</div>
</div>
<a class="anchor" id="ad3671a3c4dd0b295c4746f4fc50bbfbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad176a38b9c52c54788e86797860df757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::printMe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeType&#160;</td>
          <td class="paramname"><em>termWidth</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print some reasonable representation of this array to the the supplied stream.</p>
<p>Display this variable on the given output stream. </p>
<p>For N-ary arrays, data slice - start with [1,1,1,...,1]. We keep doing the matrix print , incrementing from the highest dimension, and rolling downwards.</p>

</div>
</div>
<a class="anchor" id="a303cf47a5ceeea987b2fe35359a90add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::promoteType </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>dstClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stringVector&#160;</td>
          <td class="paramname"><em>fNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Promote our array to a new type. For empty arrays, this type promotion always succeeds. For cell arrays, this does nothing (except throw an error if we attempt to promote it to a different type). For structure arrays, promoting to a structure array has three possible outcomes:</p><ul>
<li>If the fields match in order and contents then the promotion is successful.</li>
<li>If the fields match in contents but not in-order then the promotion involves reordering the data.</li>
<li>If the fields match in contents but the destination type has additional fields, then the promotion involves reordering the data and adding space. Throws an exception if</li>
<li>we try to convert a cell-array to another type.</li>
<li>we try to promote a structure-array to another array with an incompatible field setup (i.e., not one of the three outcomes listed above).</li>
<li>we try to convert a structure-array to a non-structure array type.</li>
<li>we try to convert any numerical types to a reference type.</li>
</ul>
<p>Promote our data to a new type.</p>
<p>Copy data from our data array to the specified array, converting the data as we go. We can only convert data to or from base types. So if the source or destination types are reference types, we cannot perform the conversion.</p>
<p>For the remaining types, we have a matrix of possibilities. Here we list the conversion rules.</p>
<p>Source type</p><ul>
<li>string<ul>
<li>logical dest = (source == 0) ? 0 : 1</li>
<li>real dest = (double) source</li>
<li>complex dest = (double) source</li>
</ul>
</li>
<li>logical<ul>
<li>string dest = (char) source</li>
<li>real dest = (double) source</li>
<li>complex dest = (double) source</li>
</ul>
</li>
<li>real<ul>
<li>string dest = (char) source</li>
<li>logical dest = (source == 0) ? 0 : 1</li>
<li>complex dest = (double) source</li>
</ul>
</li>
<li>complex<ul>
<li>string dest = (char) real(source)</li>
<li>logical dest = (real(source) == 0 &amp;&amp; imag(source) == 0) ? 0:1</li>
<li>real dest = real(source) </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a53d6932c50267e037e996791fc952441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::promoteType </td>
          <td>(</td>
          <td class="paramtype">Class&#160;</td>
          <td class="paramname"><em>new_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Promote our array to a new type. This is a shortcut for when new_type is not NLS_STRUCT_ARRAY, so that the fieldNames argument is not needed. </p>

</div>
</div>
<a class="anchor" id="a3214c5e1c4f0ba588150aaaf3844f6db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reshape an array. Reshape the array along a new set of dimensions. Valid provided that setting the dimensions of the array to a does not change the number of elements in the array. Throws an exception if the new dimension has a different number of elements than we currently have.</p>
<p>Reshape an array. This is only legal if the number of elements remains the same after reshaping. </p>

</div>
</div>
<a class="anchor" id="aa30ded9f2beed8913848aaf1882ebb65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_dimensions.html">Dimensions</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an array. Resize the array to a new set of dimensions. This resize operation puts the contents of the array at the (0,...,0) corner of the new array. </p>

</div>
</div>
<a class="anchor" id="a8a04a24d76151fdb9b41c9b3f9d918d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setArrayOfIOInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_interface.html">Interface</a> *&#160;</td>
          <td class="paramname"><em>io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the IO interface used by instances of the <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> class. </p>

</div>
</div>
<a class="anchor" id="ab2a92a544609db3d31b8c430ac0f02ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setDataPointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the contents of our data block to the supplied pointer. Set the contents of our data block to the supplied pointer. Ownership of the data block is passed to the array, i.e., the caller should not manipulate the block in any way after calling this function. To avoid recopying, ownership of the byte-array is passed to the reference counting data object <a class="el" href="class_nelson_1_1_data.html">Data</a> at this point. That means that the caller is <em>not</em> responsible for freeing the memory block. </p>

</div>
</div>
<a class="anchor" id="a5f28a5d06a9b510d5680a8f0d25c723b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setField </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the contents of a field with the supplied array. Only valid for scalar structures. Throws an exception if we are not a structure array or we are a multi-element structure-array.</p>
<p>Set the contents of a field in a structure. </p>

</div>
</div>
<a class="anchor" id="a5596079303590cef42455dd339fdda39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setFieldAsList </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the contents of a field with the supplied array. This is used when a structure array is used to hold the return of a multi-function call, i.e.: [x.foo] = foo Throws an exception if</p><ul>
<li>we are not a structure array</li>
<li>the number of elements in data is not equal to the number of elements in our array.</li>
</ul>
<p>Set the contents of a field in a structure. </p>

</div>
</div>
<a class="anchor" id="a3ff74b220bbbe86695c5c99f06079097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setNDimContents </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. This if for n-Dimensional-indexing, meaning that x{10} is really x{10,1}. Throws an exception if the index is not a scalar</p>
<p>This is the multidimensional cell-replacement function. This is for content-based indexing (curly brackets). </p>

</div>
</div>
<a class="anchor" id="ab5a6c83bf9b0be24a9c14f51cc66bf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setNDimContentsAsList </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. This if for n-Dimensional-indexing, meaning that x{10} is really x{10,1}. This is used when a cell-array is used as the return of a multi-function call, i.e.: [x{1,3:5}] = foo. Throws an exception if the number of elements in data do not match the number of indices covered by index (which is the product of the number of elements in each dimension of index).</p>
<p>This is the multidimensional cell-replacement function. This is for content-based indexing (curly brackets). </p>

</div>
</div>
<a class="anchor" id="a5b558b3f69a9dcd28bb6647be4739d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setNDimSubset </td>
          <td>(</td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. This if for n-Dimensional-indexing, meaning that x(10) is really x(10,1). Throws an exception if there is a size mismatch between the index and the data.</p>
<p>Take the contents of data, and insert this data.</p>
<p>This requires the following steps:</p><ol type="1">
<li>Compute the maximum along each dimension</li>
<li>Compute the dimensions of the right hand side</li>
<li>Check that data is either a scalar or the right size</li>
<li>If necessary, zero-extend the variable.</li>
<li>Copy in the result.</li>
</ol>
<p>This is true for integer arguments - not for logical ones. Logical indices need to be converted into integer lists before they can be used. </p>

</div>
</div>
<a class="anchor" id="ab7df999bbda12f33f387e1f77631b868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setVectorContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-indexing, meaning that the argument is assumed to refer to the elements in their order as a vector. So, x{10} is equivalent to x(:){10}, even if, say, x is 3 x 4. Throws an exception if</p><ul>
<li>the index has more than one element in it</li>
<li>the index is less than 1</li>
</ul>
<p>This is the vector version of the multidimensional cell-replacement function. This is for content-based indexing (curly brackets). Two points that make this function different than replaceData are</p><ol type="1">
<li>If the index is larger than the size, we resize to a vector of sufficient length.</li>
<li>Deletions do not occur. </li>
</ol>

</div>
</div>
<a class="anchor" id="a7a2e47a8aa3fb77b04da776eae43c9e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setVectorContentsAsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> using contents-indexing, meaning that the argument is assumed to refer to the elements in their order as a vector. So, x{10} is equivalent to x(:){10}, even if, say, x is 3 x 4. This is used when a cell-array is used as the return of a multi-function call, i.e.: [x{3:5}] = foo. Throws an exception if the number of elements in data do not match the number of indices in index.</p>
<p>This is the vector version of the multidimensional cell-replacement function. This is for content-based indexing (curly brackets). Two points that make this function different than replaceData are</p><ol type="1">
<li>If the index is larger than the size, we resize to a vector of sufficient length.</li>
<li>Deletions do not occur. </li>
</ol>

</div>
</div>
<a class="anchor" id="a641603bbbf6d76aa4f8cb686c89dc48d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::setVectorSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a subset of an <a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>. Uses vector-indexing, meaning that the argument is assumed to refer to the elements in their order as a vector. So, x(10) is equivalent to x(:)(10), even if, say, x is 3 x 4. Throws an exception if there is a size mismatch between the index and the data.</p>
<p>This is the vector version of the multidimensional replacement function.</p>
<p>This requires the following steps:</p><ol type="1">
<li>Compute the maximum along each dimension</li>
<li>Check that data is either scalar or the right size. </li>
</ol>

</div>
</div>
<a class="anchor" id="af739af3e2f0acce90a27ed421727e0bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::singleConstructor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_SINGLE object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a2ecb17d6702c4f4ea1204f57ada32dd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::stringConstructor </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>String constructor - Construct an NLS_CHAR object with the given string as a value. </p>

</div>
</div>
<a class="anchor" id="ac2e92cc13e404cfd4c0f7852a6a0fb51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::stringConstructor </td>
          <td>(</td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>String constructor - Construct an NLS_CHAR object with the given string as a value. </p>

</div>
</div>
<a class="anchor" id="aae12d72e2bdd7616798b21bbd1d93c55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::structConstructor </td>
          <td>(</td>
          <td class="paramtype">stringVector&#160;</td>
          <td class="paramname"><em>fNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayOfVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Structure constructor - this is equivalent to the built in struct command. First, we have to make sure that each entry of "values" have</p><ul>
<li>cell arrays of the same size (say MxN)</li>
<li>single element cell arrays,</li>
<li>single values. With such a setup, the output is a structure array of size MxN. Elements which are defined by a single value or a single-element cell array are replicated throughout all MxN entries. Remaining elements take their values from the cell-array. Throws an exception if</li>
<li>the number of entries in the fieldnames vector does not match the number of entries in the values vector</li>
<li>the non-scalar values do not agree in dimension </li>
</ul>
<p>First, we have to make sure that each entry of "values" have</p><ol type="1">
<li>cell arrays of the same size,</li>
<li>single element cell arrays,</li>
<li>single values.</li>
</ol>
<p>Check the type of the entry. If its a non-cell array, then then ignore this entry.</p>
<p>This is a cell-array, so look for non-scalar cell-arrays.</p>
<p>At this point we can construct the dimensions of the output.</p>
<p>The dimensions of the object have been identified. Set the dimensions of the object and the field names. Then allocate the space.</p>
<p>Work through the values, and copy the values back one at a time.</p>

</div>
</div>
<a class="anchor" id="a67247643b1bf80862e55dfc7f5ac4b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::summarizeCellEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Summarize this array when it appears in a Cell array.</p>
<p>Print this object when it is an element of a cell array. This is generally a shorthand summary of the description of the object. </p>

</div>
</div>
<a class="anchor" id="a7b86d2bea7ce4103dcbd5cd643e5b1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::testCaseMatchScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we match the scalar value in x. For strings, this is done by doing a string compare. For numerical values, we promote to a common type and do a comparison. </p>

</div>
</div>
<a class="anchor" id="a4f43a994aa8b41aad19d0b48b70020a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool Nelson::ArrayOf::testForCaseMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we match the argument x, or if x is a cell-array, returns true if we match any of the cells in x. Uses <a class="el" href="class_nelson_1_1_array_of.html#a7b86d2bea7ce4103dcbd5cd643e5b1bb">ArrayOf::testCaseMatchScalar</a> to do the actual testing. Throws an exception for non-scalars (apart from strings) or reference types. Also throws an exception if the argument is not either a scalar or a cell array. </p>

</div>
</div>
<a class="anchor" id="af59ca1b6b8b82ec41fbffa1d56dec4cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::toOrdinalType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert us to an index type Convert the current object to an ordinal one. This has different meanings for different data types.</p><ul>
<li>For string types, this conversion is not defined.</li>
<li>For logical types, this is accomplished using a linear search (done in two passes - one to identify the length of the final array, and another to identify the indices of non-zero values.</li>
<li>For double types, this is done by typecasting (truncation). A warning is emitted if the source value is fractional (non-integer) or invalid (zero or negative).</li>
<li>For complex types, this is done by typecasting. The complex part is ignored, and a warning that this is the case is emitted also. Throws an exception for string, cell, structure types, or if a zero or negative index is encountered. </li>
</ul>

</div>
</div>
<a class="anchor" id="a21f3a43644273fec3a1c413f4364e8d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::uint16Constructor </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_UINT16 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a9b62387aec45cfc89997026795dac456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::uint32Constructor </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_UINT32 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a1b522c22a2b049ad21f700732e41ddfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::uint64Constructor </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_UINT64 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a4c7ce2027ec7e3cb574d804b60ccf602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a> Nelson::ArrayOf::uint8Constructor </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>aval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar constructor - Construct an NLS_UINT8 object with a scalar value. </p>

</div>
</div>
<a class="anchor" id="a54f2ebcbb1b410e25d9b247112696945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nelson::ArrayOf::vectorResize </td>
          <td>(</td>
          <td class="paramtype">indexType&#160;</td>
          <td class="paramname"><em>max_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an array based on a vector indexing expression. This method resizes an object so that an index of the type this(n) is valid. In particular, if "this" is a scalar, then this(n) extends the array in the column dimension. If "this" is a column vector, then this(n) extends the array in the row dimension. If "this" is a row vector, then this(n) extends the array in the column direction. For an arbitrarily dimensioned array, this(n) makes the array into a row vector of length n. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Developpements/GitHub/nelson/modules/types/src/include/<a class="el" href="_array_of_8hpp_source.html">ArrayOf.hpp</a></li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_CellType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_DoubleType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_FunctionHandleType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_HandleType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_IntegersType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_LogicalType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_SingleType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_SparseType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_StringType.cpp</li>
<li>D:/Developpements/GitHub/nelson/modules/types/src/cpp/ArrayOf_StructType.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_nelson.html">Nelson</a></li><li class="navelem"><a class="el" href="class_nelson_1_1_array_of.html">ArrayOf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
